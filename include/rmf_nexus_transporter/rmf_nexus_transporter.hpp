#ifndef RMF_NEXUS_TRANSPORTER__RMF_NEXUS_TRANSPORTER_HPP_
#define RMF_NEXUS_TRANSPORTER__RMF_NEXUS_TRANSPORTER_HPP_

#include <rclcpp_lifecycle/lifecycle_node.hpp>

#include <rmf_utils/impl_ptr.hpp>

#include <nexus_transporter/Itinerary.hpp>
#include <nexus_transporter/Transporter.hpp>
#include <nexus_transporter_msgs/msg/transporter_state.hpp>

namespace rmf_nexus_transporter
{

using Itinerary = nexus_transporter::Itinerary;
using TransporterState = nexus_transporter_msgs::msg::TransporterState;
using TransportFeedback = std::function<void(const TransporterState& state)>;
using TransportCompleted = std::function<void(bool success)>;

class RmfNexusTransporter : public nexus_transporter::Transporter
{
public:
  /// Configure the transporter including getting relevant information from
  /// ROS 2 parameters. (Eg. List of destinations)
  ///
  /// \param[in] node
  /// A weak pointer to an rclcpp_lifecycle node. It is important to not
  /// store the shared_ptr obtained from locking this node as it would lead
  /// to circular dependency issues.
  /// \return True if the configuration was successful.
  virtual bool configure(
    const rclcpp_lifecycle::LifecycleNode::WeakPtr& node) override;

  /// Return true if the transporter is configured and ready.
  virtual bool ready() const override;

  /// Receive an itinerary for a destination
  ///
  /// \param[in] job_id
  /// An id for this request.
  ///
  /// \param[in] destination
  /// The name of the destination
  /// \return A nullopt is returned if the destination is not valid.
  // TODO(YV): Consider creating a separate class for destination
  virtual std::optional<Itinerary> get_itinerary(
    const std::string& job_id,
    const std::string& destination,
    const std::string& source) override;

  /// Request the transporter to go to a destination. This call should be
  /// non-blocking.
  /// \param[in] itinerary
  ///   The itinerary previously generated by the transporter.
  ///   Note: The itinerary's validity should not have expired.
  ///
  /// \param[in] feedback_cb
  ///   A callback to execute to submit feedback on the transporter's progress
  ///
  /// \param[in] completed_cb
  ///   A callback to execute to when the transportation has failed or succeeded
  virtual void transport_to_destination(
    const Itinerary& itinerary,
    TransportFeedback feedback_cb,
    TransportCompleted completed_cb,
    const std::string& signal_destination,
    const std::string& signal_source) override;

  /// Process a signal sent to this transporter, not all transporter might need
  /// this interface so it is not mandatory to implement it.
  /// \param[in] job_id
  ///   The id to send the signal to
  ///
  /// \param[in] signal
  ///   The signal to send
  ///
  /// \return true if the signal was accepted, false if it was not.
  virtual std::optional<std::string> process_signal(
    const std::string& task_id,
    const std::string& signal) override;

  /// Cancel the presently assigned task
  /// \param[in] itinerary
  ///   The itinerary of the task to cancel
  /// \return True if the cancellation was successful.
  virtual bool cancel(const Itinerary& itinerary) override;

  /// Virtual destructor
  virtual ~RmfNexusTransporter() = default;

  class Implementation;

private:
  rmf_utils::impl_ptr<Implementation> _pimpl;
};

}  // namespace rmf_nexus_transporter

#endif  // RMF_NEXUS_TRANSPORTER__RMF_NEXUS_TRANSPORTER_HPP_
